We have an undirected Graph consisting of a bunch of nodes. Nodes are
grouped to form a cluster. Only nodes are connected, clusters are not
(directly). Now we want to know, if two clusters are connected. How
can we deduce this from the information of the nodes?

Given two clusters of nodes, c1, c2, determine if there is an edge {u, v},
where u \in c1 and v \in c2.


First approach:

foreach node n in c1:
    foreach node m in c2:
        if n and m are connected:
            return true
return false


It should be possible to make it faster. Something that comes to mind
with clusters of nodes on graphs is a union-find data structure. With this
data structure, we would have a fast look-up time to find out to which
cluster a node belongs.


Second approach:

foreach node n in c1:
    foreach node m in n.neighbors:
        if m.cluster = c2:
            return true
return false


This is still pretty slow. Looping over every node in a cluster is
inefficient, because a lot of nodes in the cluster are not connected to
any nodes that are not in the cluster as well.

Considering that we need to call this operation a lot, we could
improve our performance, if we remove edges that connect nodes in the
same cluster. We would only do this "on the fly", to avoid overhead.


Improved second approach:

foreach node n in c1:
    foreach node m in n.neighbors:
        if m.cluster = c2:
            return true
        else if m.cluster = c1:
            remove m from n.neighbors
return false


Next time we call our function, every connection inside the cluster is
gone, improving performance significantly if we have a lot of inner
nodes.

However, this does not solve the larger problem that we look at every
node in c1. It would be far better to know to what nodes the cluster is
connected as a whole.

For clarification, consider something like this:


cluster_neighbors = empty set
foreach node n in c1:
    foreach node m in n.neighbors:
        if m.cluster is not c1:
            cluster_neighbors.add(m)


We should not however, construct the set of neighbor nodes like this,
because this is far too costly. Instead it would be desireable to
build it "on the fly".

Here I would like to explain how clusters are created. We start out
with every node being their own cluster, and larger clusters are
formed only by merging smaller ones. This is something else that would
be nice about a union-find like structure: it would be easy to unify
clusters.

Maybe, if we maintain a set of cluster neighbors right from the
beginning, and unify neighbor sets if we unify the clusters
themselves, this can be quite efficient!

You may have noticed, that in the above code snippet, we collect not
the neighbor sets, but the neighbor nodes themselves. This is not what
we want actually; the question we started with was, how we can know if
two clusters are connected. This is easy to fix though:


neighbor_clusters = empty set
foreach node n in c1:
    foreach node m in n.neighbors:
        if m.cluster is not c1:
            cluster_neighbors.add(m.cluster)


Notice that a set is used to keep track of the neighbor clusters,
therefore calling add with duplicates is not a problem.


I believe what we ended up with is a modified version of union-find,
where every set or cluster keeps track of its neighbor sets.
